const asyncHandler = require('express-async-handler');
const Alert = require('../models/Alert');
const { sendMail } = require('../utils/sendmail');

// Helper: build Google Maps/Waze links and reverse-geocode when API key available
async function enrichLocation(lat, lng) {
  const latStr = Number(lat);
  const lngStr = Number(lng);
  const coords = `${latStr},${lngStr}`;

  const mapsSearch = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(coords)}`;
  const mapsPlace = `https://www.google.com/maps/place/${encodeURIComponent(coords)}/@${encodeURIComponent(coords)},17z`;
  const mapsDir = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(coords)}`;
  const waze = `https://www.waze.com/ul?ll=${encodeURIComponent(latStr)}%2C${encodeURIComponent(lngStr)}&navigate=yes`;

  const result = {
    coords,
    mapsSearch,
    mapsPlace,
    mapsDir,
    waze,
    staticMap: null,
    address: null
  };

  const apiKey = process.env.GOOGLE_MAPS_API_KEY;
  if (apiKey) {
    // static map (safe to include; will 404 without key)
    result.staticMap = `https://maps.googleapis.com/maps/api/staticmap?center=${encodeURIComponent(coords)}&zoom=17&size=600x300&markers=color:red%7C${encodeURIComponent(coords)}&key=${encodeURIComponent(apiKey)}`;

    // attempt reverse geocoding using global fetch if available
    try {
      const geocodeUrl = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${encodeURIComponent(coords)}&key=${encodeURIComponent(apiKey)}`;
      if (typeof globalThis.fetch === 'function') {
        const resp = await globalThis.fetch(geocodeUrl);
        if (resp && resp.ok) {
          const data = await resp.json();
          if (data && Array.isArray(data.results) && data.results.length > 0) {
            result.address = data.results[0].formatted_address || null;
          }
        }
      }
    } catch (e) {
      console.warn('reverse geocode failed', e && e.message);
    }
  }

  return result;
}

// Helper: send emails for an alert immediately (used after resolve)
async function sendEmailsForAlert(alert, req) {
  try {
    const a = await Alert.findById(alert._id).populate('victimID');
    if (!a) return;

    const lat = a.location?.latitude;
    const lng = a.location?.longitude;
    if (typeof lat !== 'number' || typeof lng !== 'number') {
      console.warn('Cannot send SOS emails: invalid lat/lng for alert', a._id);
      return;
    }

    const loc = await enrichLocation(lat, lng);
    const subject = `SOS Alert ‚Äî ${a.alertID || 'Unknown ID'}`;
    const victimInfo = a.victimID ? `${a.victimID.firstName || ''} ${a.victimID.lastName || ''}`.trim() || `Victim: ${a.victimID._id}` : 'Victim: unknown';

    const accuracy = (typeof a.location?.accuracy === 'number') ? `${Math.round(a.location.accuracy)} m` : null;
    const sampleTime = a.location?.timestamp ? new Date(a.location.timestamp).toLocaleString() : null;

    const addressHtml = loc.address ? `<p>Address: <b>${loc.address}</b></p>` : '';
    const staticMapHtml = loc.staticMap ? `<p><a href="${loc.mapsSearch}" target="_blank" rel="noopener noreferrer"><img src="${loc.staticMap}" alt="map" style="max-width:100%;height:auto;border:1px solid #ccc"/></a></p>` : '';

    const html = `
      <p><strong>Emergency SOS</strong></p>
      <p>${victimInfo}</p>
      <p>Alert ID: <b>${a.alertID}</b></p>
      ${addressHtml}
      ${staticMapHtml}
      <p>Location: <a href="${loc.mapsSearch}" target="_blank" rel="noopener noreferrer">${loc.coords}</a></p>
  ${accuracy ? `<p>Reported accuracy: <b>${accuracy}</b></p>` : ''}
  ${sampleTime ? `<p>Sample time: <b>${sampleTime}</b></p>` : ''}
  <p>Time: ${new Date(a.createdAt).toLocaleString()}</p>
      <hr>
      <p>This message was generated by the VAWCare Barangay Support System.</p>
    `;

    const recipients = new Set();
    const defaultRecipient = process.env.SOS_RECIPIENT || 'jadenyuki486@gmail.com';
    recipients.add(defaultRecipient);
    if (a.victimID && Array.isArray(a.victimID.emergencyContacts)) {
      for (const c of a.victimID.emergencyContacts) {
        if (c && c.email && typeof c.email === 'string' && c.email.trim()) {
          recipients.add(c.email.trim().toLowerCase());
        }
      }
    }

    // record that SOS processing started
    try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: req.user?._id || a.victimID || null, action: 'send_sos', details: `SOS send initiated for alert ${a.alertID || a._id}` }); } catch (e) { console.warn('Failed to record send_sos log', e && e.message); }

    // Send a single email to VAWC Desk and every emergency contact
    const recipientsArr = Array.from(recipients);
    try {
      const info = await sendMail(recipientsArr, subject, html);
      const accepted = Array.isArray(info && info.accepted) ? info.accepted.map(x => String(x).toLowerCase()) : [];
      const rejected = Array.isArray(info && info.rejected) ? info.rejected.map(x => String(x).toLowerCase()) : [];
      for (const recipient of recipientsArr) {
        const low = String(recipient).toLowerCase();
        try {
          await a.addNotifiedContact({
            contactID: `email-${recipient}`,
            name: (a.victimID && a.victimID.emergencyContacts ? (a.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === low) || {}).name : '') || recipient,
            contactNumber: (a.victimID && a.victimID.emergencyContacts ? (a.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === low) || {}).contactNumber : '') || '',
            notificationTime: new Date(),
            notificationStatus: accepted.includes(low) ? 'Sent' : 'Failed'
          });
        } catch (e) { console.warn('Failed to record notified contact', e && e.message); }
        try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: a.victimID || null, action: accepted.includes(low) ? 'sos_email_sent' : 'sos_email_failed', details: `SOS email ${accepted.includes(low) ? 'sent' : 'failed'} to ${recipient} for alert ${a.alertID || a._id}` }); } catch (e) { /* ignore */ }
      }
    } catch (err) {
      console.error('Failed to send SOS emails to recipients', recipientsArr, err && err.message);
      for (const recipient of recipientsArr) {
        try { await a.addNotifiedContact({ contactID: `email-${recipient}`, name: recipient, contactNumber: '', notificationTime: new Date(), notificationStatus: 'Failed' }); } catch (e) { /* ignore */ }
        try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: a.victimID || null, action: 'sos_email_failed', details: `SOS email failed to ${recipient} for alert ${a.alertID || a._id}: ${err && err.message}` }); } catch (e) { /* ignore */ }
      }
    }
  } catch (e) {
    console.warn('sendEmailsForAlert error', e && e.message);
  }
}

// Resolve an alert by id (sets status to 'Resolved')
const resolveAlert = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const alert = await Alert.findById(id).populate('victimID');
  if (!alert) {
    res.status(404);
    throw new Error('Alert not found');
  }

  const now = new Date();
  // Determine durationMs preferring client-supplied value
  alert.resolvedAt = now;
  // Prefer client-provided durationMs if present and plausible
  const clientDuration = Number(req.body?.durationMs);
  const MAX_DURATION_MS = 1000 * 60 * 60 * 24; // 24 hours upper bound
  try {
    if (!Number.isNaN(clientDuration) && clientDuration >= 0 && clientDuration < MAX_DURATION_MS) {
      alert.durationMs = clientDuration;
    } else if (alert.createdAt) {
      alert.durationMs = now.getTime() - new Date(alert.createdAt).getTime();
    } else {
      alert.durationMs = null;
    }
  } catch (e) {
    alert.durationMs = null;
  }

  // Decide whether this is a cancellation: short duration means accidental press
  const CANCEL_WINDOW_MS = Number.isFinite(parseInt(process.env.ALERT_CANCEL_WINDOW_MS, 10)) ? parseInt(process.env.ALERT_CANCEL_WINDOW_MS, 10) : 5000; // 5s by default
  const isCancelled = (typeof alert.durationMs === 'number') && (alert.durationMs < CANCEL_WINDOW_MS);

  // Diagnostic logging for quick debugging when durations are unexpectedly 0 or status mismatches
  try {
    console.log('resolveAlert debug:', {
      alertId: alert._id,
      clientProvided: req.body?.durationMs,
      durationMs: alert.durationMs,
      cancelWindowMs: CANCEL_WINDOW_MS,
      isCancelled
    });
  } catch (e) { /* ignore logging errors */ }

  // Set status based on cancellation window
  alert.status = isCancelled ? 'Cancelled' : 'Resolved';

  // compute durationStr HH:MM:SS
  if (typeof alert.durationMs === 'number') {
    const totalSeconds = Math.max(0, Math.floor(alert.durationMs / 1000));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    const pad = (n) => String(n).padStart(2, '0');
    alert.durationStr = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
  } else {
    alert.durationStr = '00:00:00';
  }

  await alert.save();

  // After saving, decide whether to send SOS emails based on duration threshold
  try {
    const THRESH_MS = parseInt(process.env.SOS_DURATION_MS, 10) || 5000;
    // Only send SOS emails when not cancelled and duration passes threshold
    const existingEmails = Array.isArray(alert.notifiedContacts) ? alert.notifiedContacts.filter(n => (n.contactID || '').startsWith('email-')) : [];
    if (!isCancelled && typeof alert.durationMs === 'number' && alert.durationMs >= THRESH_MS && existingEmails.length === 0) {
      sendEmailsForAlert(alert, req).catch((e) => console.warn('sendEmailsForAlert failed', e && e.message));
    } else {
      console.log('Skipping SOS emails on resolve/cancel: cancelled=', isCancelled, 'durationMs=', alert.durationMs);
    }
  } catch (e) { console.warn('Error deciding SOS send on resolve', e && e.message); }

  // record system log (best-effort)
  try {
    const { recordLog } = require('../middleware/logger');
    await recordLog({ req, actorType: 'victim', actorId: alert.victimID || null, action: 'alert_resolved', details: `Alert ${alert.alertID} resolved` });
  } catch (e) {
    console.warn('Failed to record alert resolved log', e && e.message);
  }

  res.status(200).json({ success: true, message: 'Alert resolved', data: { id: alert._id, alertID: alert.alertID, resolvedAt: alert.resolvedAt, durationMs: alert.durationMs, durationStr: alert.durationStr, status: alert.status } });
});

// List alerts with optional filters (status)
const listAlerts = asyncHandler(async (req, res) => {
  const { status } = req.query;
  const filter = {};
  if (status) filter.status = status;
  const alerts = await Alert.find(filter).sort({ createdAt: -1 }).populate('victimID');
  res.status(200).json({ success: true, data: alerts });
});

// Send SOS email containing a Google Maps link to a fixed recipient.
// POST /api/alerts/:id/sos
const sendSOSEmail = asyncHandler(async (req, res) => {
  try {
    console.log('üî¥ RECEIVED SOS REQUEST', { id: req.params.id, timestamp: new Date().toISOString() });
    const { id } = req.params;

    const alert = await Alert.findById(id).populate('victimID');
    if (!alert) {
      console.log('‚ùå Alert not found:', id);
      return res.status(404).json({ success: false, message: 'Alert not found' });
    }

    const lat = alert.location?.latitude;
    const lng = alert.location?.longitude;

    if (typeof lat !== 'number' || typeof lng !== 'number') {
      console.log('‚ùå Invalid location:', { lat, lng });
      return res.status(400).json({ success: false, message: 'Alert does not have valid latitude/longitude' });
    }

  // Wait a confirmation window so short accidental presses don't spam contacts
  const CONFIRM_MS = Number.parseInt(process.env.SOS_CONFIRM_MS, 10) || 5000;
  await new Promise((resolve) => setTimeout(resolve, CONFIRM_MS));

  // Re-fetch alert to ensure latest status and createdAt
  const fresh = await Alert.findById(id).populate('victimID');
  if (!fresh) {
    res.status(404);
    throw new Error('Alert not found after confirmation delay');
  }

  // Skip if alert is no longer active
  if (fresh.status && fresh.status !== 'Active') {
    return res.status(200).json({ success: false, message: 'Alert not active after confirmation window; skipping SOS emails' });
  }

  const createdAt = fresh.createdAt ? new Date(fresh.createdAt).getTime() : null;
  const ageMs = createdAt ? (Date.now() - createdAt) : null;
  if (ageMs !== null && ageMs < CONFIRM_MS) {
    return res.status(200).json({ success: false, message: 'Alert duration below confirmation threshold; skipping SOS emails', ageMs });
  }

  const loc = await enrichLocation(lat, lng);
  const subject = `SOS Alert ‚Äî ${alert.alertID || 'Unknown ID'}`;
  const victimInfo = fresh.victimID ? `${fresh.victimID.firstName || ''} ${fresh.victimID.lastName || ''}`.trim() || `Victim: ${fresh.victimID._id}` : 'Victim: unknown';

  const accuracy = (typeof alert.location?.accuracy === 'number') ? `${Math.round(alert.location.accuracy)} m` : null;
  const sampleTime = alert.location?.timestamp ? new Date(alert.location.timestamp).toLocaleString() : null;

  const addressHtml = loc.address ? `<p>Address: <b>${loc.address}</b></p>` : '';
  const staticMapHtml = loc.staticMap ? `<p><a href="${loc.mapsSearch}" target="_blank" rel="noopener noreferrer"><img src="${loc.staticMap}" alt="map" style="max-width:100%;height:auto;border:1px solid #ccc"/></a></p>` : '';

  const html = `
    <p><strong>Emergency SOS</strong></p>
    <p>${victimInfo}</p>
    <p>Alert ID: <b>${alert.alertID}</b></p>
    ${addressHtml}
    ${staticMapHtml}
    <p>Location: <a href="${loc.mapsSearch}" target="_blank" rel="noopener noreferrer">${loc.coords}</a></p>
  ${accuracy ? `<p>Reported accuracy: <b>${accuracy}</b></p>` : ''}
  ${sampleTime ? `<p>Sample time: <b>${sampleTime}</b></p>` : ''}
  <p>Time: ${new Date(alert.createdAt).toLocaleString()}</p>
    <hr>
    <p>This message was generated by the VAWCare Barangay Support System.</p>
  `;

  // Build recipient list: default SOS recipient + any emergency contact emails on victim
  const recipients = new Set();
  const defaultRecipient = process.env.SOS_RECIPIENT || 'jadenyuki486@gmail.com';
  recipients.add(defaultRecipient);

  if (alert.victimID && Array.isArray(alert.victimID.emergencyContacts)) {
    for (const c of alert.victimID.emergencyContacts) {
      if (c && c.email && typeof c.email === 'string' && c.email.trim()) {
        recipients.add(c.email.trim().toLowerCase());
      }
    }
  }

  const results = [];
  // record that SOS processing started
  try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: req.user?._id || alert.victimID || null, action: 'send_sos', details: `SOS processing started for alert ${alert.alertID || alert._id}` }); } catch (e) { console.warn('Failed to record send_sos log', e && e.message); }
  const recipientsArr = Array.from(recipients);
  console.log('üîµ SOS EMAIL: Attempting to send to', recipientsArr);
  try {
    const info = await sendMail(recipientsArr, subject, html);
    console.log('‚úÖ SOS EMAIL SUCCESS:', { accepted: info?.accepted, rejected: info?.rejected });
    const accepted = Array.isArray(info && info.accepted) ? info.accepted.map(x => String(x).toLowerCase()) : [];
    const rejected = Array.isArray(info && info.rejected) ? info.rejected.map(x => String(x).toLowerCase()) : [];
    for (const recipient of recipientsArr) {
      const low = String(recipient).toLowerCase();
      try {
        await alert.addNotifiedContact({
          contactID: `email-${recipient}`,
          name: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === low) || {}).name : '') || recipient,
          contactNumber: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === low) || {}).contactNumber : '') || '',
          notificationTime: new Date(),
          notificationStatus: accepted.includes(low) ? 'Sent' : 'Failed'
        });
      } catch (e) { console.warn('Failed to record notified contact', e && e.message); }
      results.push({ recipient, status: accepted.includes(low) ? 'Sent' : 'Failed' });
    }
  } catch (err) {
    console.error('‚ùå SOS EMAIL FAILED:', {
      recipients: recipientsArr,
      error: err?.message,
      code: err?.code,
      stack: err?.stack
    });
    for (const recipient of recipientsArr) {
      try { await alert.addNotifiedContact({ contactID: `email-${recipient}`, name: recipient, contactNumber: '', notificationTime: new Date(), notificationStatus: 'Failed' }); } catch (e) { /* ignore */ }
      results.push({ recipient, status: 'Failed' });
    }
  }

  // Record per-recipient results
  try {
    const { recordLog } = require('../middleware/logger');
    for (const r of results) {
      const act = r.status === 'Sent' ? 'sos_email_sent' : 'sos_email_failed';
      try { await recordLog({ req, actorType: req.user?.role || 'victim', actorId: alert.victimID || null, action: act, details: `SOS email ${r.status} to ${r.recipient} for alert ${alert.alertID || alert._id}` }); } catch (e) { /* ignore */ }
    }
  } catch (e) { console.warn('Failed to record per-recipient SOS logs', e && e.message); }

  // If any recipient succeeded, return success
  if (results.some(r => r.status === 'Sent')) {
    res.status(200).json({ success: true, message: 'SOS email(s) processed', results });
  } else {
    res.status(500).json({ success: false, message: 'Failed to send SOS emails', results });
  }
  } catch (outerErr) {
    console.error('‚ùå UNHANDLED ERROR IN sendSOSEmail:', {
      message: outerErr?.message,
      code: outerErr?.code,
      stack: outerErr?.stack
    });
    return res.status(500).json({ 
      success: false, 
      message: 'Internal server error: ' + (outerErr?.message || 'Unknown error'),
      error: process.env.NODE_ENV === 'development' ? outerErr?.message : undefined
    });
  }
});

// export additional function
module.exports = { resolveAlert, listAlerts, sendSOSEmail };
