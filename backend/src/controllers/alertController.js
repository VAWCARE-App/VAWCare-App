const asyncHandler = require('express-async-handler');
const Alert = require('../models/Alert');
const { sendMail } = require('../utils/sendmail');

// Helper: send emails for an alert immediately (used after resolve)
async function sendEmailsForAlert(alert, req) {
  try {
    const a = await Alert.findById(alert._id).populate('victimID');
    if (!a) return;

    const lat = a.location?.latitude;
    const lng = a.location?.longitude;
    if (typeof lat !== 'number' || typeof lng !== 'number') {
      console.warn('Cannot send SOS emails: invalid lat/lng for alert', a._id);
      return;
    }

    const mapsLink = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(lat + ',' + lng)}`;
    const subject = `SOS Alert — ${a.alertID || 'Unknown ID'}`;
    const victimInfo = a.victimID ? `${a.victimID.firstName || ''} ${a.victimID.lastName || ''}`.trim() || `Victim: ${a.victimID._id}` : 'Victim: unknown';

    const html = `
      <p><strong>Emergency SOS</strong></p>
      <p>${victimInfo}</p>
      <p>Alert ID: <b>${a.alertID}</b></p>
      <p>Location: <a href="${mapsLink}" target="_blank" rel="noopener noreferrer">${lat}, ${lng}</a></p>
      <p>Time: ${new Date(a.createdAt).toLocaleString()}</p>
      <hr>
      <p>This message was generated by the VAWCare Barangay Support System.</p>
    `;

    const recipients = new Set();
    const defaultRecipient = process.env.SOS_RECIPIENT || 'jadenyuki486@gmail.com';
    recipients.add(defaultRecipient);
    if (a.victimID && Array.isArray(a.victimID.emergencyContacts)) {
      for (const c of a.victimID.emergencyContacts) {
        if (c && c.email && typeof c.email === 'string' && c.email.trim()) {
          recipients.add(c.email.trim().toLowerCase());
        }
      }
    }

    // record that SOS processing started
    try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: req.user?._id || a.victimID || null, action: 'send_sos', details: `SOS send initiated for alert ${a.alertID || a._id}` }); } catch(e) { console.warn('Failed to record send_sos log', e && e.message); }

    for (const recipient of Array.from(recipients)) {
      try {
        await sendMail(recipient, subject, html);
        try {
          await a.addNotifiedContact({
            contactID: `email-${recipient}`,
            name: (a.victimID && a.victimID.emergencyContacts ? (a.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).name : '') || recipient,
            contactNumber: (a.victimID && a.victimID.emergencyContacts ? (a.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).contactNumber : '') || '',
            notificationTime: new Date(),
            notificationStatus: 'Sent'
          });
        } catch (e) { console.warn('Failed to record notified contact', e && e.message); }
        try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: a.victimID || null, action: 'sos_email_sent', details: `SOS email sent to ${recipient} for alert ${a.alertID || a._id}` }); } catch(e) { /* ignore */ }
      } catch (err) {
        console.error('Failed to send SOS email to', recipient, err && err.message);
        try { await a.addNotifiedContact({ contactID: `email-${recipient}`, name: recipient, contactNumber: '', notificationTime: new Date(), notificationStatus: 'Failed' }); } catch(e) { /* ignore */ }
        try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: a.victimID || null, action: 'sos_email_failed', details: `SOS email failed to ${recipient} for alert ${a.alertID || a._id}` }); } catch(e) { /* ignore */ }
      }
    }
  } catch (e) {
    console.warn('sendEmailsForAlert error', e && e.message);
  }
}

// Resolve an alert by id (sets status to 'Resolved')
const resolveAlert = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const alert = await Alert.findById(id).populate('victimID');
  if (!alert) {
    res.status(404);
    throw new Error('Alert not found');
  }

  const now = new Date();
  // Determine durationMs preferring client-supplied value
  alert.resolvedAt = now;
  // Prefer client-provided durationMs if present and plausible
  const clientDuration = Number(req.body?.durationMs);
  const MAX_DURATION_MS = 1000 * 60 * 60 * 24; // 24 hours upper bound
  try {
    if (!Number.isNaN(clientDuration) && clientDuration >= 0 && clientDuration < MAX_DURATION_MS) {
      alert.durationMs = clientDuration;
    } else if (alert.createdAt) {
      alert.durationMs = now.getTime() - new Date(alert.createdAt).getTime();
    } else {
      alert.durationMs = null;
    }
  } catch (e) {
    alert.durationMs = null;
  }

  // Decide whether this is a cancellation: short duration means accidental press
  const CANCEL_WINDOW_MS = Number.isFinite(parseInt(process.env.ALERT_CANCEL_WINDOW_MS, 10)) ? parseInt(process.env.ALERT_CANCEL_WINDOW_MS, 10) : 3000; // 3s by default
  const isCancelled = (typeof alert.durationMs === 'number') && (alert.durationMs < CANCEL_WINDOW_MS);

  // Diagnostic logging for quick debugging when durations are unexpectedly 0 or status mismatches
  try {
    console.log('resolveAlert debug:', {
      alertId: alert._id,
      clientProvided: req.body?.durationMs,
      durationMs: alert.durationMs,
      cancelWindowMs: CANCEL_WINDOW_MS,
      isCancelled
    });
  } catch (e) { /* ignore logging errors */ }

  // Set status based on cancellation window
  alert.status = isCancelled ? 'Cancelled' : 'Resolved';

  // compute durationStr HH:MM:SS
  if (typeof alert.durationMs === 'number') {
    const totalSeconds = Math.max(0, Math.floor(alert.durationMs / 1000));
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const seconds = totalSeconds % 60;
    const pad = (n) => String(n).padStart(2, '0');
    alert.durationStr = `${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
  } else {
    alert.durationStr = '00:00:00';
  }

  await alert.save();

  // After saving, decide whether to send SOS emails based on duration threshold
  try {
    const THRESH_MS = parseInt(process.env.SOS_DURATION_MS, 10) || 3000;
    // Only send SOS emails when not cancelled and duration passes threshold
    if (!isCancelled && typeof alert.durationMs === 'number' && alert.durationMs >= THRESH_MS) {
      // fire-and-forget
      sendEmailsForAlert(alert, req).catch((e) => console.warn('sendEmailsForAlert failed', e && e.message));
    } else {
      console.log('Skipping SOS emails on resolve/cancel: cancelled=', isCancelled, 'durationMs=', alert.durationMs);
    }
  } catch (e) { console.warn('Error deciding SOS send on resolve', e && e.message); }

  // record system log (best-effort)
  try {
    const { recordLog } = require('../middleware/logger');
    await recordLog({ req, actorType: 'victim', actorId: alert.victimID || null, action: 'alert_resolved', details: `Alert ${alert.alertID} resolved` });
  } catch (e) {
    console.warn('Failed to record alert resolved log', e && e.message);
  }

  res.status(200).json({ success: true, message: 'Alert resolved', data: { id: alert._id, alertID: alert.alertID, resolvedAt: alert.resolvedAt, durationMs: alert.durationMs, durationStr: alert.durationStr, status: alert.status } });
});

// List alerts with optional filters (status)
const listAlerts = asyncHandler(async (req, res) => {
  const { status } = req.query;
  const filter = {};
  if (status) filter.status = status;
  const alerts = await Alert.find(filter).sort({ createdAt: -1 }).populate('victimID');
  res.status(200).json({ success: true, data: alerts });
});

module.exports = { resolveAlert, listAlerts };

// Send SOS email containing a Google Maps link to a fixed recipient.
// POST /api/alerts/:id/sos
const sendSOSEmail = asyncHandler(async (req, res) => {
  const { id } = req.params;

  const alert = await Alert.findById(id).populate('victimID');
  if (!alert) {
    res.status(404);
    throw new Error('Alert not found');
  }

  const lat = alert.location?.latitude;
  const lng = alert.location?.longitude;

  if (typeof lat !== 'number' || typeof lng !== 'number') {
    res.status(400);
    throw new Error('Alert does not have valid latitude/longitude');
  }

  // Wait a confirmation window so short accidental presses don't spam contacts
  const CONFIRM_MS = 3000;
  await new Promise((resolve) => setTimeout(resolve, CONFIRM_MS));

  // Re-fetch alert to ensure latest status and createdAt
  const fresh = await Alert.findById(id).populate('victimID');
  if (!fresh) {
    res.status(404);
    throw new Error('Alert not found after confirmation delay');
  }

  // Skip if alert is no longer active
  if (fresh.status && fresh.status !== 'Active') {
    return res.status(200).json({ success: false, message: 'Alert not active after confirmation window; skipping SOS emails' });
  }

  const createdAt = fresh.createdAt ? new Date(fresh.createdAt).getTime() : null;
  const ageMs = createdAt ? (Date.now() - createdAt) : null;
  if (ageMs !== null && ageMs < CONFIRM_MS) {
    return res.status(200).json({ success: false, message: 'Alert duration below confirmation threshold; skipping SOS emails', ageMs });
  }

  const mapsLink = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(lat + ',' + lng)}`;
  const subject = `SOS Alert — ${alert.alertID || 'Unknown ID'}`;
  const victimInfo = fresh.victimID ? `${fresh.victimID.firstName || ''} ${fresh.victimID.lastName || ''}`.trim() || `Victim: ${fresh.victimID._id}` : 'Victim: unknown';

  const html = `
    <p><strong>Emergency SOS</strong></p>
    <p>${victimInfo}</p>
    <p>Alert ID: <b>${alert.alertID}</b></p>
    <p>Location: <a href="${mapsLink}" target="_blank" rel="noopener noreferrer">${lat}, ${lng}</a></p>
    <p>Time: ${new Date(alert.createdAt).toLocaleString()}</p>
    <hr>
    <p>This message was generated by the VAWCare Barangay Support System.</p>
  `;

  // Build recipient list: default SOS recipient + any emergency contact emails on victim
  const recipients = new Set();
  const defaultRecipient = process.env.SOS_RECIPIENT || 'jadenyuki486@gmail.com';
  recipients.add(defaultRecipient);

  if (alert.victimID && Array.isArray(alert.victimID.emergencyContacts)) {
    for (const c of alert.victimID.emergencyContacts) {
      if (c && c.email && typeof c.email === 'string' && c.email.trim()) {
        recipients.add(c.email.trim().toLowerCase());
      }
    }
  }

  const results = [];
  // record that SOS processing started
  try { const { recordLog } = require('../middleware/logger'); await recordLog({ req, actorType: req.user?.role || 'victim', actorId: req.user?._id || alert.victimID || null, action: 'send_sos', details: `SOS processing started for alert ${alert.alertID || alert._id}` }); } catch(e) { console.warn('Failed to record send_sos log', e && e.message); }
  for (const recipient of Array.from(recipients)) {
    try {
      await sendMail(recipient, subject, html);
      try {
        await alert.addNotifiedContact({
          contactID: `email-${recipient}`,
          name: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).name : '') || recipient,
          contactNumber: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).contactNumber : '') || '',
          notificationTime: new Date(),
          notificationStatus: 'Sent'
        });
      } catch (e) {
        console.warn('Failed to record notified contact', e && e.message);
      }
      results.push({ recipient, status: 'Sent' });
    } catch (err) {
      console.error('Failed to send SOS email to', recipient, err && err.message);
      try {
        await alert.addNotifiedContact({
          contactID: `email-${recipient}`,
          name: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).name : '') || recipient,
          contactNumber: (alert.victimID && alert.victimID.emergencyContacts ? (alert.victimID.emergencyContacts.find(ec => (ec.email || '').toLowerCase() === recipient) || {}).contactNumber : '') || '',
          notificationTime: new Date(),
          notificationStatus: 'Failed'
        });
      } catch (e) { /* ignore */ }
      results.push({ recipient, status: 'Failed' });
    }
  }

  // Record per-recipient results
  try {
    const { recordLog } = require('../middleware/logger');
    for (const r of results) {
      const act = r.status === 'Sent' ? 'sos_email_sent' : 'sos_email_failed';
      try { await recordLog({ req, actorType: req.user?.role || 'victim', actorId: alert.victimID || null, action: act, details: `SOS email ${r.status} to ${r.recipient} for alert ${alert.alertID || alert._id}` }); } catch(e) { /* ignore */ }
    }
  } catch(e) { console.warn('Failed to record per-recipient SOS logs', e && e.message); }

  // If any recipient succeeded, return success
  if (results.some(r => r.status === 'Sent')) {
    res.status(200).json({ success: true, message: 'SOS email(s) processed', results });
  } else {
    res.status(500).json({ success: false, message: 'Failed to send SOS emails', results });
  }
});

// export additional function
module.exports = { resolveAlert, listAlerts, sendSOSEmail };
